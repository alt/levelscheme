% \iffalse
%<*internal>
%% File: levelscheme.dtx by Arno Trautmann, mail: arno dot trautmann at gmx dot de
\iffalse
%</internal>
%<*readme>
# levelscheme
levelscheme is a LaTeX package that tries to offer an easy way of drawing atomic and molecular level schemes in a LaTeX document.

## installation
The dtx file has to be compiled with XeLaTeX in order to get the pdf documentation. The package itself can be used with any up-to-date LaTeX-flavour.

## requirements
This package requires the expl3 packages, xparse and the TikZ bundle. Make shure all are installed and up to date.

Any comments and suggestions are welcome! Help me improve this package!

Contact me: arno dot trautmann at gmx dot de.
%</readme>
%<*internal>
\fi
\begingroup
%</internal>
%<*batchfile>
\input docstrip.tex
\keepsilent
\preamble
EXPERIMENTAL CODE

Do not distribute this file without also distributing the
source files specified above.

Do not distribute a modified version of this file under the same name.

\endpreamble
\postamble
Copyright 2010 Arno Trautmann <arno.trautmann@gmx.de>

Distributed under the LaTeX Project Public License,
verson 1.3c or higher (your choice). The latest version of
this license is at: http://www.latex-project.org/lppl.txt

This work is "author-maintained" by Arno Trautmann

This work conists of this file levelscheme.dtx
         and the derived files levelscheme.sty
                                  and  levelscheme.pdf.
\endpostamble
\askforoverwritefalse

\generate{\file{levelscheme.sty}{\from{levelscheme.dtx}{levelscheme}}}
\generate{\file{levelscheme-example.tex}{\from{levelscheme.dtx}{example}}}
%</batchfile>
%<batchfile>\endbatchfile
%<*internal>
\generate{\file{levelscheme.ins}{\from{levelscheme.dtx}{batchfile}}}
\nopostamble\nopreamble
\generate{\file{readme.markdown}{\from{levelscheme.dtx}{readme}}}
\endgroup
%</internal>
%
%<*driver>
\documentclass[a4paper]{ltxdoc}
\usepackage[english]{babel}
\usepackage{
  hyperref,
  xltxtra
}

\hypersetup{%
  pdfborder= 0 0 0,
  colorlinks=true,
  linkcolor= blue,
  pdftitle=levelscheme
}

\EnableCrossrefs
\CodelineIndex
\RecordChanges
\usepackage{
  array,
  levelscheme,
  showexpl
}

\lstset{%
  backgroundcolor=\color[rgb]{.9 .9 .9},
  basicstyle=\ttfamily\small,
  breakindent=1em,
  breaklines=true,
  captionpos=b,
  numbers=none,
  frame=tlbr,
  frameround=tttt,
  rframe=,
  pos=l,
  explpreset={preset=\vspace*{-9ex}}
}

%\OnlyDescription

\def\filedate{2010/08/01}
\def\fileversion{0.1a}

\title{The \textsf{levelscheme} package}
\author{Arno L. Trautmann\thanks{arno.trautmann@gmx.de}}
\date{Version \fileversion,\ \filedate}

\begin{document}
\maketitle
\begin{abstract}
The package |levelscheme| tries to offer an easy way of drawing atomic or molecular level schemes. You can connect levels with different transitions, all by a very simple interface with many possibilities of changing the way everything looks.
 
Any comments are welcome; please help me improve this package or its documentation. If you have suggestions regarding the user interface or want any special cool feature implemented, just mail me!
\end{abstract}
\tableofcontents
\newpage
\part{Documentation}
\section{Introduction}
This package aims to provide an easy and fast way to draw atomic level schemes. It is designed for theses in the atomic, molecular or quantum optical sciences to help quickly sketch the idea of a certain (experimental) situation. |levelscheme| is \emph{not} intended to offer rigorous calculations and exact potential forms etc. It is just an alternative to drawing things in Paint.

\section{Usage}
You draw \hyperref[sec:levels]{levels} using the command |\level[1]{mylevel}|, give them names and labels and connect them via physical meaningful \hyperref[sec:transitions]{transitions}:
\begin{LTXexample}[caption=A simple example.,preset={\vspace*{-10ex}\shifttrans{-.5}}]
\begin{levelscheme}
\level[1]{A}
\virtuallevel[3]{B}
\level[2][color=red] {C}
\absorb[color=green] BA
\shifttrans{-.5}
\emit BC
\shifttrans{.8}
\nophotoncycle[no,near end,color=blue] AC
\end{levelscheme}
\end{LTXexample}

You have many options to change everything to your needs: arrow directions, photon length and direction, positions, distances, colors, thickness etc. by using few and quite intuitive commands. All command names are inspired by what they describe, so there is no „line with arrows at both sides“ but rather |\cycle| for „cycling transition“.

There are three classes of commands: Such that represent \hyperref[sec:levels]{levels}, commands for \hyperref[sec:transitions]{transitions} and  commands or environments for \hyperref[sec:potentials]{potentials}, respectively.

\subsection{Levels}
\label{sec:levels}
To allow transitions between levels, every level must have a unique name. This name is given as the mandatory argument of the |\level| command.

All level commands take \emph{two} optional arguments: the first optional argument in brackets is a label that will be printed next to the level bar. You can give arbitrary names and labels, of course. The second optional argument takes options for that level and can be given as key-value or keys only. (see section \ref{sec:leveloptions}

\DescribeMacro{\level[][]\{\}}
Draws a line that represents an energy level. Takes two arguments, the second being the unique name of the level. The first argument is optional and contains a label to be printed next to the level.

\DescribeMacro{\minorlevel[][]\{\}}
Same as normal |\level|, but with a thin stroke. This way you can have a better overview of your levels and emphasize important levels. Use with care as too many different stroke types will confuse the reader!

\DescribeMacro{\virtuallevel[][]\{\}}
A level that does not exist in some way, but does in another … however, it is dashed. Useful e.\,g. for Raman transitions.

\DescribeMacro{\nolevel[][]\{\}}
Such a level does not exist at all. Nevertheless you can draw transitions to it. This is useful if you want to depict detuning of the laser. If you shine in red-detuned light, draw the upper level, then a |\nolevel|, then the lower level, and use an absorption from lower to |\nolevel|. This way the transition does not go up all the way to the upper level and it is clear that this photon cannot be absorbed.

\DescribeMacro{\sublevels\{level\}\{-1,-5,3,4\}}
This command draws a bunch of sublevels. These will be right of the given ”main level“ (here |A|) and vertically shifted with respect to that one by the given numbers.

\begin{LTXexample}[title={A totally messed up and buggy code … this will hopefully be corrected!},preset={\sublevelwidth{1}\levelwidth{0.5}}]
\begin{levelscheme}
\level{A}
\sublevels{A}{-1,0,1,1.5}
\end{levelscheme}
\end{LTXexample}

\subsection{Transitions}
\label{sec:transitions}
There are many kinds of possible transitions. For most of them there are special commands. All of them can be adjusted by means of options given in brackets. |\cyle[no]| denotes a forbidden cycling transition. For possible options see section \ref{sec:transoptions} below.

All transition commands take three arguments: The first one is an optional argument taking key or key-value pairs. The second and third argument denote the starting and ending level, respectively.

The ”time axis“ is taken from left to right, therefore an absorbed photon is coming from the left, an emitted photon is going to the right. This can be changed via options.

\DescribeMacro{\absorb[]\{\}\{\}}
Depicts an absorption process, i.\,e. an arrow directing from the first level to the second one with a photon running ”inwards“. By default, the photon comes from the right and is absorbed in the middle of the transition.

\DescribeMacro{\emit[]\{\}\{\}}
Same as above, emits a photon. The photon goes to the right by default.

\DescribeMacro{\cycle[]\{\}\{\}}
Connects two states via an bidirectional arrow, with a photon. The photon is coming from the left. This might be inconsequent and so it is.

\DescribeMacro{\nophotoncycle[]\{\}\{\}}
Dito, without a photon.

\DescribeMacro{\transition*[]\{\}\{\}}
This is our working horse. The |\transition| macro does all the work and is thus quite powerful. It is \emph{not} intended for the normal user as it’s syntax is quite complex. Use on of the abbreviations above, they all rely on |\transition|. The star notes a photonless transition, while no star is for a transition with photon.

\section{Options}
\subsection{Options for Levels}
\label{sec:leveloptions}
\begin{description}
\item[color=] color of the level.
\item[thickness=] thickness of the level. Can take the following values which can also be given alone as shorthand:
\item[thick] draws a thick level
\item[very thick] draws a very thick levl
\item[thin] draws a thin level (default for minorlevel)
\item[very thin] draws a very thin level (be careful, this might not be rendered correctly on your screen and may look totally different when printed!)
\item[…] …
\end{description}

\subsection{Options for Transitions}
\label{sec:transoptions}
Options are given to the commands in square brackets |[]|. This is mostly done by a key-value or key only interface. Some options can be set using special macros (e.\,g. for global options that affect all following transitions or levels etc.)

\begin{description}
\item[no] A forbidden transition. This will cross out the transition arrow.
\item[not allowed] same as [no].
\item[yes] the opposite of [no]. (this way you can force the existence of a photon)
\item[color=] color of the transition-arrow. The photon stays (yet) black.
\item[near end] causes the photon to appear nearer to the end of the transition than to the middle. This is useful to adjust the position of the photon.
\item[near start] dito, but for the beginning of the transition
\item[dir=] denotes the position of the photon relative to the transition arrow; possible values are |left| and |right|.
\item[left] shorthand for |dir=left|
\item[right] shorthand for |dir=right|
\end{description}


\DescribeMacro{\cascadeto*[]\{\}\{\}}
The cascade macro is very useful if you want to draw decays (or absorbtions …) for several levels. You can just put a number of levels into the third (mandatory) argument, and all of these levels will decay  into (or absorb from or to, whatever) the level given in the last argument. The type of transition can be given in the optional argument, where |\relaxation| is default. The starred version does not shift the transitions horizontally, while the non-starred version does. The starred version is quite nonsense and may vanish the next days …

\DescribeMacro{\cascadeall*[]\{\}}
Similar to the above macro, but now every given level decays into the next one. So give |{A,B,C}| to draw decay from A to B and from B to C. The starred version does not shift the transitions horizontally, while the non-starred version does.

\begin{LTXexample}[preset={\leveldistance{0.5} \levelwidth{2.5}\shifttrans{-2}}]
\begin{levelscheme}
  \level A \level B
  \level C \level D
  \cascadeto{A,B,C}D
  \cascadeall*{A,B,C}D
\end{levelscheme}
\end{LTXexample}

\DescribeMacro{\cascadeallto*[]\{\}}
A quite useless combination of the two above macros. Will lead to unusefull arrows all over your levels.

\subsection{Potentials}
\label{sec:potentials}
This package is able to draw several important potentials and to insert levels. These might be at arbitrary hight or even have the correct position (as in the case of the harmonic oszillator).

\DescribeMacro{\HO[]\{\}}
This macro draws a harmonic oszillator, i.\,e. a parabola with equidistant levels and an offset of half the level distance. The first argument gives the number of levels (default are four). The second argument is not used so far.

\DescribeMacro{Lennard-Jones}
Draws a Lennard-Jones potential. Levels can be included using some cool macro that is not yet really implemented. I think I will change this to a custom version of |whateverpotential|.

\DescribeMacro{Morse}
Draws a Morse potential. Levels can be included using some cool macro that is not yet really implemented. Dito $\to$ |whateverpotential|
\subsubsection{Your own potential}
\DescribeMacro{Whatever potential}
This is a nice toy to do whatever you want: The environment |whateverpotential|\footnote{Name may change if I find a better one.} draws a potential with a function given by the user. Then one can draw levels at given hights that have the correct position and distance.

The following example shows your possibilities:\footnote{As far as implemented. We’ll see what the future brings. It’s up to you to suggest improvements …}
\vspace{1.8cm}
\begin{LTXexample}[pos=t]
\begin{whateverpotential}(-5:5){-cos(50*\x)}{1/50*acos(\x)}{-1/50*acos(\x)}
\potentiallevel{-0.3}
\potentiallevel{0.3}[-2.15][2.15]
\potentiallevel{-1}
\end{whateverpotential}
\end{LTXexample}

The first two arguments in braces are mandatory arguments. The range, given in parenthesis, is optional, as well as the third argument in braces. You have to adjust it accordng to your function to avoid arithmetic overflow in \TeX. (Also, an exponential function might rapidly grow out of your sheet …)

The first mandatory argument is the potential to be plotted. You might choose any function the pgf package understand. Note that the variable must be given as |\x|. Of course you can add constants as \TeX\ macros. (|\b| instead of 50).

The second mandatory argument is the inverse of the aferementioned function. This is needed to calculate the right positions of the level to be inserted later. Again, this can be any function. You can mess up things totally here by giving a function that does not fit the main function. But you should not …

The third argument in braces is optional. As the inverse of a function is not unique, thee must be a second inverse function. By default, we assume a symetric function, and therefore the second inverse is the negative of the first inverse. So this is redundant in the above example, but is necessary for asymmetric potentials.

\DescribeMacro{\potentiallevel\{\}[][]}
This is a special version of the |\level| macro fitting the needs of |whateverpotential|. %% No, it is not?
If you have a quite simple potential, you can use it with one argument only, which is the vertical position of the level. This is then drawn from the left to the right according to the function you specified.

If this goes wrong by any means, you can explicitly tell where to draw the line. This might happen in the above case when the level should be above 0 where the inverse function is not correct anymore. Then you can specify an arbitrary function that will be evaluated at the given value. I.\,e. |\potentiallevel{5}[sin(\x)][cos(\x)| will give you a level at hight 5 with right and left end at -0.96 and 0.28, respectively. That does not make much sense, but you also can just insert a number (which is a constant function) and the level will have the left end at this number and the right end at the negative number if you don’t give a second number in brackets. If so, that second number will be the right end.

\subsection{Coolness}
These are just some pre-coded things that are often used. All of the following schemes can be drawn with the user level macros above, but as they might be used quite often, they are given here. If you don’t like the way they are implemented, just copy the code and use it the way you like. If you have a nice change in something, please let me know it, I’d love to offer alternative solutions for special needs or change the default definitions.
\DescribeMacro{lambdascheme}
\DescribeMacro{EIT}

\StopEventually{}
\clearpage

\part{Implementation: levelscheme.sty}

\DocInput{levelscheme.dtx}
\end{document}
%</driver>
%<*levelscheme>
% \fi
% \setcounter{section}{0}
% \section{Preamble}
% Preamble stuff, package loading. We use |xparse| due to superior macro definition as well as |expl3| (required by xparse) to get the nice |l3keys|.
% 
% Last, special tikz-libraries for arrows etc.
%    \begin{macrocode} 
\ProvidesPackage{levelscheme}
  [2010/06/27 v 0.a1 atomic/molecular level schemes]
\RequirePackage{
  forloop,
  tikz,
  xparse
}
\usetikzlibrary{%
	arrows,%
	decorations.pathmorphing,%
	positioning%
}
\usepgflibrary{%
	shapes.misc%
}
\ExplSyntaxOn
%    \end{macrocode}
% \section{Keys}
% keys:
%    \begin{macrocode}
\keys_define:nn{ls_trans}{
  dir.code:n = \tl_set:Nn\ls_trans_dir{#1},
  right.meta:n = {dir=right},
  left.meta:n = {dir=left},
% kind of arrows used
  arrow.code:n = \tl_set:Nn\ls_trans_arrow{{#1}},
  {<->}.meta:n = \tl_set:Nn\ls_trans_arrow{{<->}},
%  location of the transition relative to the previous transition (kind of)
  loc.code:n = \tl_set:Nn\ls_trans_loc{#1},
%
  pos.code:n = \tl_set:Nn\ls_trans_pos{#1},
  midway.meta:n = {pos=midway},
  near~end.meta:n = {pos=near~end},
  near~start.meta:n = {pos=near~start},
  no.code:n = \bool_set_false:N\ls_trans_allowed,
  not~allowed.meta:n = {no},
  yes.code:n = \bool_set_true:N\ls_trans_allowed,
  color.code:n = \tl_set:Nn\ls_trans_color{#1},
  thickness.code:n = \tl_set:Nn\ls_trans_thick{#1},
  thick.meta :n = {thickness = thick},
  very~thick.meta :n = {thickness = very~thick},
  thin.meta :n = {thickness = thin},
  very~thin.meta :n = {thickness = very~thin},
}

\keys_define:nn{ls_level}{
  color.code:n = \tl_set:Nn\ls_level_color{#1},
  thickness.code:n = \tl_set:Nn\ls_level_thick{#1},
  thick.meta :n = {thickness = thick},
  very~thick.meta :n = {thickness = very~thick},
  thin.meta :n = {thickness = thin},
  very~thin.meta :n = {thickness = very~thin},
}

\keys_define:nn{ls_pot}{
  domain.code:n = \tl_set:Nn\ls_pot_domain{#1}
}
%    \end{macrocode}
% Interface for setting keys:
% intern command to set keys (all keys)
% this here needs some clean-up.
%    \begin{macrocode}
\cs_new:Nn\ls_setkeys:n{%
  \keys_set:nn{ls}{#1}%
}%
%    \end{macrocode}
% intern command to set keys (transitions only)
%    \begin{macrocode}
\cs_new:Nn\ls_setkeys_trans:n{%
  \keys_set:nn{ls_trans}{#1}
}
%    \end{macrocode}
% intern command to set keys (levels only)
%    \begin{macrocode}
\cs_new:Nn\ls_setkeys_level:n{%
  \keys_set:nn{ls_level}{#1}
}
%    \end{macrocode}
% user level command
%    \begin{macrocode}
\NewDocumentCommand\lssetkeys{o m}{%
  \IfNoValueTF{#1}
    {\ls_setkeys:n{#2}}
    {\keys_set:nn{ls_#1}{#2}}
}
%    \end{macrocode}
%\section{Constants and Variables}
% setting up constants/varibles with default values.
%    \begin{macrocode}
\bool_new:N\ls_trans_allowed
\bool_new:N\ls_first_of_cascade

\tl_gset:Nn\c_ls_right{right}

\tl_set:Nn\ls_levelwidth{2}
\tl_set:Nn\ls_leveldistance{1}

\tl_set:Nn\ls_sublevelwidth{1}
\tl_set:Nn\ls_subleveldistance{0.5}

\tl_set:Nn\ls_trans_not_width{2em}
\tl_set:Nn\ls_trans_not_height{2ex} %% not yet used

\tl_set:Nn\ls_level_style{}
\tl_set:Nn\ls_level_thick{thick}
\tl_set:Nn\ls_trans_thick{thin}

\tl_set:Nn\ls_level_color{black}
\tl_set:Nn\ls_trans_color{black}

\fp_new:c{transdist}  %% must be changed to some floating number!
\fp_gset:cn{transdist}{1}
\fp_new:c{ls_trans_shift}  %% must be changed to some floating number!
\fp_gset:cn{ls_trans_shift}{1}

\tikzset{ls-decoration/.style={decorate,decoration={snake}}}

\DeclareExpandableDocumentCommand\photonlength{}{1.2}
\DeclareExpandableDocumentCommand\finestructlength{}{2}

\newcounter{finestruct}  %% needed bye the for-loop of sublevels  (?) anywhere, as that package does not get clear with expl3-counts
\newcounter{HOlevel}   %% needed by the for-loop in the harmonic oszillator

%    \end{macrocode}
% User level macros to set them
%    \begin{macrocode}
\DeclareDocumentCommand\leveldistance{m}{
  \tl_gset:Nn\ls_leveldistance{#1}
}
\DeclareDocumentCommand\levelwidth{m}{
  \tl_gset:Nn\ls_levelwidth{#1}
}
\DeclareDocumentCommand\sublevelwidth{m}{
  \tl_gset:Nn\ls_sublevelwidth{#1}
}
\DeclareDocumentCommand\subleveldistance{m}{
  \tl_gset:Nn\ls_subleveldistance{#1}
}
\DeclareDocumentCommand\levelcolor{m}{
  \tl_gset:Nn\ls_level_color{#1}
}
\DeclareDocumentCommand\levelthickness{m}{
  \tl_gset:Nn\ls_level_thick{#1}
}
\DeclareDocumentCommand\transitionthickness{m}{
  \tl_gset:Nn\ls_trans_thick{#1}
}
\ExplSyntaxOff
%    \end{macrocode}
% \section{Level Scheme}
% This is the main environment of this package, and almost everything elese is based on this. Mostly, it is just a wrapper for a |tikzpicture| with some settings.
%    \begin{macrocode}
\ExplSyntaxNamesOn
\DeclareDocumentEnvironment{levelscheme}{O{}}
{
  \begin{tikzpicture}[#1,inner sep=0mm,>=stealth]%
    \node (lastlevel) at (0,0){};%
}
{
  \end{tikzpicture}
}
%    \end{macrocode}
% One of the two most important macros: |\level|. Guess what it does ;)
%    \begin{macrocode}
\DeclareDocumentCommand\level{O{}O{}m}{  %% 1ˢᵗ arg = label, 2ⁿᵈ arg = options
  \ls_setkeys_level:n{#2}
  \begin{scope}[node distance = \ls_leveldistance and \ls_levelwidth]
    \node (#3) [below=of lastlevel] {\llap{#1\ }};
    \node (#3-2) [right=of #3] {};
    \node (#3-3) [right=of #3-2] {};
    \draw [\ls_level_thick,\ls_level_color,\ls_level_style] (#3.center) -- (#3-3.center);
    \node (lastlevel) at (#3) {};
    \node (lastlevel-3) at (#3-3){};
    \fp_set:cn{transdist}{1}  %% return to normal distance
  \end{scope}
}
%% a minor level, i.e. this one is drawn thinner than the others
\DeclareDocumentCommand\minorlevel{O{}m}{
  \tl_set:Nn\ls_level_style{thin}
  \level[#1]{#2}
  \tl_set:Nn\ls_level_style{}
}
%% virtual level that does not really exist. But anyhow it does … or not  … whatever, it is dashed!
\DeclareDocumentCommand\virtuallevel{O{}m}{
  \tl_set:Nn\ls_level_style{dashed}
  \level[#1]{#2}
  \tl_set:Nn\ls_level_style{}
}
%% 
\DeclareDocumentCommand\nolevel{O{}m}{
  \tl_set:Nn\ls_level_style{white}
  \level[#1]{#2}
  \tl_set:Nn\ls_level_style{}
}
%    \end{macrocode}
% A number of sublevels of given distances
%    \begin{macrocode}
%% first, a helper macro (there should be much more of these here around!)
\DeclareDocumentCommand\extractlabels{}{
  
}
\cs_new:Nn\ls_onesublevel:n{
  \node(mytest){\argi, \argii, \argiii, außerdem #1};
}
%% then the main macro
\DeclareDocumentCommand\sublevels{O{lastlevel-3}mm}
{
  \node (sublevelstart) [right=of #1.center]{};
\def\argii{#2}
\def\argi{#1}
\def\argiii{#3}
  \clist_map_function:nN{#3}{\ls_onesublevel:n}
%  \foreach \x in {#3}{%
%%%\cs_new:Nn\ls_onesublevel:nnn{
%%%    \node (#2-tmp) [%
%%%      node distance= \x*\ls_subleveldistance,%
%%%      above=of sublevelstart.south%
%%%      ]{};
%%%    \draw (#1.center) -- (#2-tmp.center) -- +(\ls_sublevelwidth,0) node (end-#2-tmp) {\hbox to 2em{\hfill}};
%%%  }
}
%    \end{macrocode}
% An attempt to implement the possibility to use several columns of levels, e.\,g. for para- and ortho-Helium. Not yet useable.
%    \begin{macrocode}
\DeclareDocumentCommand\levelcolumns{O{1.5}O{3}m}
%% first argument: relative width of levels: width = 1.5/m*levelwidth
%% second argument: relative shift (horizontal) of levels: distance = 1.5/m*levelwidth
{
  \tl_set:Nx\ls_levelwidth{\ls_levelwidth*#1/#3}
  \tl_set:Nx\ls_levelcolumnshift{\ls_levelwidth*#2}
  \node (columnuppernode) at (lastlevel) {};
  \node (columnuppernode-2) [right=of columnuppernode] {};
  \node (columnuppernode-3) [right=of columnuppernode-2] {};
}
\DeclareDocumentCommand\nextlevelcolumn{}
{
  \node (columnuppernode) [right=\ls_levelcolumnshift of columnuppernode]{};
  \node (columnuppernode-2) [right=of columnuppernode] {};
  \node (columnuppernode-3) [right=of columnuppernode-2] {};
  \node (lastlevel) at (columnuppernode) {};
}
%    \end{macrocode}
% a set of sublevels at constant distances
% \begin{macro}{finestruct}
%    \begin{macrocode}
\NewDocumentCommand\finestruct{mmm}{
  \fp_set:cn{transdist}{0}
  \node (finestart) [right=of lastlevel-3]{};
  \forLoop{1}{#1}{finestruct}{
    \node (#3-\thefinestruct) [%
      node distance= #2*(-#1/2+(\thefinestruct-.5)),%
      above=of finestart.south%
      ]{};
  \draw (lastlevel-3.center) to (#3-\thefinestruct.center) -- +(2,0) node (end-#3-\thefinestruct) {};
  }
}
%    \end{macrocode}
% \end{macro}
% \subsection{Transitions}
% A transition. This is kind of the basic macro for nearly everything interesting. I hope it is configurable enough to be really useful. However, key-value is as expandable as one wishes, so the first argument is a key-value list for everyeverything.
%    \begin{macrocode}
\DeclareDocumentCommand\transition{sO{}O{}mmm}{
  \ls_setkeys_trans:n{%
      loc=\fp_use:c{transdist},midway,arrow={->},yes, %% default values
   #2}  %% user values
%
%% construct nodes and draw the thing, define a center at which the photon ends
%
  \node (translow) [node distance = \ls_trans_loc ,right=of #4] {};
  \node (transup) [node distance = \ls_trans_loc,right=of #5] {};
  \draw [\ls_trans_arrow,\ls_trans_color,#3,\ls_trans_thick] (translow.center) -- (transup.center) node (photonend)[\ls_trans_pos]{};
%
%% calculate the beginning of the photon, depending wether it comes/goes to/from left or right
%
  \IfBooleanTF{#1}{}{ %% is there a photon in this transition? i.e. no star given
  \tl_if_eq:ccTF{ls_trans_dir}{c_ls_right}  %% does the photon come from right or left?
      {\node [node distance = \photonlength](photonstart) [right=of photonend] {};}
      {\node [node distance = \photonlength](photonstart) [left=of photonend]   {};}
    \photon[#6]{photonstart}{photonend};
  }
  \bool_if:NF\ls_trans_allowed{
    \node [cross out,draw = black] (notallowed) at (photonend)
              {\hspace*{\ls_trans_not_width}\strut};
  }
%
  \fp_gadd:Nn\transdist{\ls_trans_shift}  %% and shift the next transition so they will not overlap. Has to be adjusted for left/right
}
%    \end{macrocode}
% for shifting/not shifting the transitions by hand
%    \begin{macrocode}
\NewDocumentCommand\shifttrans{m}{
  \fp_gadd:cn{transdist}{#1}
}
\NewDocumentCommand\shiftdist{m}{
  \fp_gset:cn{ls_trans_shift}{#1}
}
\NewDocumentCommand\stopshift{}{
  \fp_gset:cn{ls_trans_shift_last}{\ls_trans_shift}
  \fp_gset:cn{ls_trans_shift}{0}
}
\NewDocumentCommand\resumeshift{}{
  \fp_gset:cn{ls_trans_shift}{\ls_trans_shift_last}
}
%    \end{macrocode}
% a transition with arrows at both sides to indicate that a cyled transition is meant; with or without photon
%    \begin{macrocode}
\NewDocumentCommand\cycle{O{}mm}{
  \transition*[#1,arrow={<->}]{#2}{#3}{}
}
\NewDocumentCommand\photoncycle{O{}mm}{
  \transition[#1,arrow={<->}]{#2}{#3}{->}
}
\NewDocumentCommand\nophotoncycle{O{}mm}{
  \transition*[#1,arrow={<->},no]{#2}{#3}{->}
}
%    \end{macrocode}
% a single photon from node 1 to node 2
%    \begin{macrocode}
\NewDocumentCommand\photon{O{->}mm}{
  \draw [#1,decorate,decoration={snake,pre length=4,post length=4}] (#2) -- (#3);
}
%    \end{macrocode}
% absorbtion of a photon, a special transition
%    \begin{macrocode}
\NewDocumentCommand\absorb{O{midway,dir=left}mm}{
  \transition[#1]{#2}{#3}{->}
}
%    \end{macrocode}
% emission of a photon, another special transition
%    \begin{macrocode}
\NewDocumentCommand\emit{O{midway}mm}{
  \transition[right,#1]{#2}{#3}{<-}
}
%    \end{macrocode}
% Induced emission. The alignment of the photons is quite suboptimal. There needs to be a more flexible interface to photons.
%    \begin{macrocode}
\NewDocumentCommand\indemit{O{midway,dir=right}mm}{
  \stopshift
  \absorb{#2}{#3}
  \emit{#2}{#3}
  \tl_set:Nn\ls_ind_photondist{0.15}
  \node (photonend) at (photonend) [above=\ls_ind_photondist] {};
  \node (photonstart) at (photonstart) [above=\ls_ind_photondist] {};
  \photon{photonend}{photonstart}
  \resumeshift
}
%    \end{macrocode}
% photonless transition
%    \begin{macrocode}
\NewDocumentCommand\relaxation{O{midway,dir=right}mm}{
  \transition*[#1][ls-decoration]{#2}{#3}{<-}
}
%    \end{macrocode}
% If decay into several levels is possible, you don’t have to do alle stuff by hand, but rather use this one:
%    \begin{macrocode}
\NewDocumentCommand\cascadeto{sO{\relaxation}mm}{
  \IfBooleanT #1 {\stopshift}
  \foreach \x in {#3}{%
    #2{\x}{#4}
  }
}
%    \end{macrocode}
% It‘s also possible to decay step by step one after the other. This can be done with the following:
%    \begin{macrocode}
\NewDocumentCommand\cascadeall{sO{\relaxation}mm}{
  \IfBooleanT #1 {\stopshift}
  \bool_set_true:N\ls_first_of_cascade  
  \foreach \x in {#3}{%
  \bool_if:NTF\ls_first_of_cascade
    {\bool_gset_false:N\ls_first_of_cascade}
    {#2{lastcasclevel}{\x}}
     \node (lastcasclevel) at (\x){};
  }
  #2{lastcasclevel}{#4}
}
%    \end{macrocode}
% Last and least: A not-so-useful offer to combine the above macros. The output is ugly, thoug …
%    \begin{macrocode}
\NewDocumentCommand\cascadeallto{sO{\relaxation}mm}{
  \IfBooleanT #1 {\stopshift}
  \bool_set_true:N\ls_first_of_cascade  
  \foreach \x in {#3}{%
  \bool_if:NTF\ls_first_of_cascade
    {\bool_gset_false:N\ls_first_of_cascade}
    {#2{lastcasclevel}{\x}}
     \node (lastcasclevel) at (\x){};
     #2{lastcasclevel}{#4}
  }
}
%    \end{macrocode}
% \subsection{$\Lambda$ scheme}
% The environment |lambdascheme| is usefull to draw a $\Lambda$ shaped niveau system. For example, use it to depicture the EIT effect.
%    \begin{macrocode}
\NewDocumentEnvironment{lambdascheme}{}
  {\begin{levelscheme}
    \tl_set:Nn\ls_levelwidth{1}
    \tl_set:Nn\ls_lambdaApos{1.5,4}
    \tl_set:Nn\ls_lambdaBpos{3,1}
    \tl_set:Nn\ls_lambdaCpos{0,0}
    \node (lastlevel) at (\ls_lambdaApos){};
    \level{lambda-A}
    \node (lastlevel) at (\ls_lambdaBpos){};
    \level{lambda-B}
    \node (lastlevel) at (\ls_lambdaCpos){};
    \level{lambda-C}
    \cycle{lambda-C}{lambda-A}
    \shifttrans{-\ls_levelwidth}
    \cycle{lambda-B}{lambda-A}
  }
  {\end{levelscheme}}
%    \end{macrocode}
% \subsection{Zooming in}
% For some cases it is helpfull to draw an overview of the levels on the left-hand side of a scheme, and a zoomed version of an interesting part on the right-hand side. (e.\,g. rotational sublevles of vibrational states)
%    \begin{macrocode}
\DeclareDocumentCommand\zoomlevels{mm}
{
%  \node (lastlevel) [right=of (lastlevel-3)] {};
  \node (lastlevel) at (#1-3) [above right=1 and 2] {};
  \leveldistance{0}
  \level{zoomed-#1}
  \node (lastlevel) at (#2-3) [below right=1 and 2] {};
  \leveldistance{0}
  \level{zoomed-#2}
  \draw[dashed] (#1-3) -- (zoomed-#1);
  \draw[dashed] (#2-3) -- (zoomed-#2);
  \node (lastlevel) at (zoomed-#1) {};
}
%    \end{macrocode}
% \section{Potentials}
%The macros presented in this section enable you to draw some of the typical potentials needed in atomic and molecular physics. Plans are to implement a hormonic potential, Morse potential, Lennard-Jones potential, a gaussian potential (optical dipole trap) and a linear potential. This is \emph{not} intended for rigorous calculations and scientific things, just for sketching. If you need exakt forms of potentials and level distances, go for a professional program.
%\subsection{He-Ne laser}
%Typeset your own laser! The command  |\HeNelaser| does most of the work for you!
%    \begin{macrocode}
\NewDocumentCommand\HeNelaser{}{
\level{hene-heground}
\level{hene-he2¹s}
\level{hene-he2¹s}
\level{hene-he2³s}
\level{hene-ne3s}
\level{hene-he2s}
\level{hene-ne3p}
\level{hene-ne2p}
\level{hene-ne2¹s}
\level{hene-neground}
}
%    \end{macrocode}
%\subsection{MOT}
%    \begin{macrocode}
\NewDocumentCommand\MOT{}{
\begin{levelscheme}
  \level{MOT-upper}
  \tl_set:Nn\ls_motdistance{0.95}
  \node (MOT-plus-right) [node distance=\ls_motdistance,above = of MOT-upper-3] {};
  \node (MOT-plus-left) [node distance=\ls_motdistance,below = of MOT-upper] {};
  \node (MOT-minus-right) [node distance=\ls_motdistance,below = of MOT-upper-3] {};
  \node (MOT-minus-left) [node distance=\ls_motdistance,above = of MOT-upper] {};
% 
  \leveldistance{0.5}
  \virtuallevel{MOT-middle}
  \leveldistance{3}
  \level{MOT-lower}
%
  \draw (MOT-plus-left) -- (MOT-plus-right);
  \draw (MOT-minus-left) -- (MOT-minus-right);
  \absorb[loc=0.3*\ls_levelwidth]{MOT-lower}{MOT-middle}
  \absorb[right,loc=1.7*\ls_levelwidth]{MOT-lower}{MOT-upper}
\end{levelscheme}
}
%    \end{macrocode}
% \subsection{Harmonic Oszillator}
%    \begin{macrocode}
\tl_set:Nn\lsHOhight{0.5}
\tl_set:Nn\lsHOwidth{0.5}

\group_begin:
  \char_set_lccode:nn { `\! } { `\: }
  \char_make_other:N \!
\tl_to_lowercase:n {
  \group_end:
  \cs_new:Npn\setdomains#1#2{
  \pgfkeys {tikz/domain = #1 ! #2}
  }
}

\NewDocumentCommand\HO{O{4}m}{
\setdomains{-2}{2}
  \begin{tikzpicture}
    \draw plot (\x,{\x^2*\lsHOwidth}){};
    \forLoop{0}{#1}{HOlevel}{
      \def\HOL{{(\theHOlevel+0.5)*\lsHOhight}}
      \draw ({sqrt(\HOL/\lsHOwidth)},\HOL) -- ({-sqrt(\HOL/\lsHOwidth)},\HOL){};
  }
  \end{tikzpicture}
}
\ExplSyntaxNamesOff
%    \end{macrocode}
%\subsection{Lennard-Jones potential}
%    \begin{macrocode}
  \DeclareDocumentCommand\potlevel{m}{
    \def\potlevelleft{%
      {2^(1/6)/\ljSigma*((sqrt(\ljEpsilon^2+#1*\ljEpsilon)/#1) - (\ljEpsilon/#1))^(1/6)-0.03*#1}% %% WTF correction summand needed?!?
    }
    \def\potlevelright{
      {2^(1/6)/\ljSigma*((-sqrt(\ljEpsilon^2+#1*\ljEpsilon)/#1) - (\ljEpsilon/#1))^(1/6)}%
    }
    \draw (\potlevelleft,#1) -- (\potlevelright,#1){};
}
\NewDocumentEnvironment{lennardjones}{mm}
{
  \gdef\ljEpsilon{#1}
  \gdef\ljSigma{#2}
  \setdomains{1}{4}
  \begin{tikzpicture}
  \draw plot[smooth] (\x,{4*\ljEpsilon*((\ljSigma*\x)^(-12)-(\ljSigma*\x)^(-6))}){};
}{
  \end{tikzpicture}
}
%    \end{macrocode}
%\subsection{Morse potential}
%    \begin{macrocode}
\NewDocumentEnvironment{morsepotential}{O{}}
{
%%%  \ls_setkeys_potential{#1}
  \begin{tikzpicture}[domain=1:3]
    \draw plot[smooth] (\x,{(1*(1-exp(-0.7*(\x*2-1))))^2}){};
    \draw plot[smooth] (\x,{(1*(1-exp(-0.7*(\x*2-1))))^2+0.3}){};
}{
  \end{tikzpicture}
}
%    \end{macrocode}
% \subsection{Whatever potential}
% The user gives the function of a potential and it‘s inverted function. Then this environment draws the potential itself and a special level-macro draws levels at a given hight. Man, that’s awesome!
%    \begin{macrocode}
\NewDocumentEnvironment{whateverpotential}{D(){1:3}mmg}
{
  \gdef\lsinvertpotleft{#3}
  \IfNoValueTF{#4}
    {\gdef\lsinvertpotright{-#3}}   %% wtf this works! :)
    {\gdef\lsinvertpotright{#4}}
  \begin{tikzpicture}[domain=#1]
    \draw plot[smooth] (\x,{#2}){};
}{
  \end{tikzpicture}
}
\NewDocumentCommand\potentiallevel{mO{\lsinvertpotleft}O{\lsinvertpotright}}{ 
    \def\x{#1}
    \draw ({#2},#1) -- ({#3},#1){};
}
%    \end{macrocode}
% \clearpage
% \appendix
% \part{Appendix}
% \section{Known Bugs}
% This should be a list of (serious) bugs. Please report any of them to me!
% \begin{itemize}
% \item |sublevels| is totally f***ed up!
% \item wtf is wrong with the index?!
% \item HeNe is not ready …
% \item MOT beams should be aligned and all at same hight
% \item photons in induced emission should be vertically centered (symmetrically)
% \item offset in Lennard-Jones potential has to be removed. No idea what is going wrong there
% \end{itemize}
% \section{todo – missing features}
% Here a section with some ideas that could be implemented.
% \begin{itemize}
% \item improve spacing of photons (they are too narrow to the transition)
% \item do labels using the label mechanism of tizk instead of stupidly do llap (but how – tikz example on p. 42 does not work!)
% \item whateverlevel cannot have labels, cannot be used for transitions, cannot do nothing :-/
% \item free positioning of levels (length, horizontal pos)
% \item sublevels cannot have labels -> call as |\sublevels{(1 a),(2 b)}| etc. Parse this to a macro that checks for brace – if not, print level at given number, if so, extract first argument and label with second one.
% \item pump beams for laser transitions
% \item levels of a LED (solid state energy levels)
% \item how about some axes with cool features?
% \item Feshbach resonances
% \item implement colors (e.\,g. Na, Li)
% \item implement whole correct hyperfine schemes (data?!)
% \item implement bound/unbound molecular schemes as used in chemistry
% \item …
% \end{itemize}
% \newpage
% \PrintIndex
% \iffalse
%</levelscheme>
% \fi
% \Finale
\endinput